--- a/hostapd/config_file.c
+++ b/hostapd/config_file.c
@@ -3459,6 +3459,8 @@
 		conf->noscan = atoi(pos);
 	} else if (os_strcmp(buf, "ht_coex") == 0) {
 		conf->no_ht_coex = !atoi(pos);
+	} else if (os_strcmp(buf, "intel_lar") == 0) {
+		conf->intel_lar = atoi(pos);
 	} else if (os_strcmp(buf, "ieee80211n") == 0) {
 		conf->ieee80211n = atoi(pos);
 	} else if (os_strcmp(buf, "ht_capab") == 0) {
--- a/src/ap/ap_config.h
+++ b/src/ap/ap_config.h
@@ -1050,6 +1050,7 @@
 	u16 ht_capab;
 	int noscan;
 	int no_ht_coex;
+	int intel_lar;
 	int ieee80211n;
 	int secondary_channel;
 	int no_pri_sec_switch;
--- a/src/ap/hw_features.c	
+++ b/src/ap/hw_features.c
@@ -26,6 +26,17 @@
 #include "beacon.h"
 #include "hw_features.h"
 
+static void ieee80211n_do_nothing(struct hostapd_iface *iface)
+{
+			wpa_printf(MSG_DEBUG,
+				   "Scan finished!");
+}
+
+static void ieee80211n_scan_channels_2g4(struct hostapd_iface *iface,
+					 struct wpa_driver_scan_params *params);
+static void ieee80211n_scan_channels_5g(struct hostapd_iface *iface,
+					struct wpa_driver_scan_params *params);
+
 
 void hostapd_free_hw_features(struct hostapd_hw_modes *hw_features,
 			      size_t num_hw_features)
@@ -82,6 +93,33 @@
 
 	if (hostapd_drv_none(hapd))
 		return -1;
+
+	//if (!iface->conf->noscan) {
+	if (iface->conf->intel_lar && !iface->conf->noscan) { 
+       // scan
+	struct wpa_driver_scan_params params;
+	int ret1;
+
+	os_memset(&params, 0, sizeof(params));
+	ieee80211n_scan_channels_5g(iface, &params);
+
+	ret1 = hostapd_driver_scan(iface->bss[0], &params);
+       
+        if (ret1 == -EBUSY) {
+                wpa_printf(MSG_ERROR,
+                           "Failed to request a scan of neighboring BSSes ret=%d (%s)!",
+                           ret1, strerror(-ret1));
+        }
+
+        if (ret1 == 0) {
+                iface->scan_cb = ieee80211n_do_nothing;
+                wpa_printf(MSG_DEBUG,
+                           "Sleeping...");
+                for (int i=0; i<110; i++) {
+                  usleep(100000);
+                }
+        } 
+	}
 	modes = hostapd_get_hw_feature_data(hapd, &num_modes, &flags,
 					    &dfs_domain);
 	if (modes == NULL) {

@@ -308,7 +346,6 @@
 			       sec_chan);
 }
 
-
 static void ieee80211n_check_scan(struct hostapd_iface *iface)
 {
 	struct wpa_scan_results *scan_res;
@@ -517,8 +554,10 @@
 	int ret;
 
 	/* Check that HT40 is used and PRI / SEC switch is allowed */
-	if (!iface->conf->secondary_channel || iface->conf->no_pri_sec_switch)
+	if (!iface->conf->secondary_channel || iface->conf->no_pri_sec_switch || iface->conf->noscan) {
+                wpa_printf(MSG_DEBUG, "Not scanning due to noscan?");
 		return 0;
+        }
 
 	hostapd_set_state(iface, HAPD_IFACE_HT_SCAN);
 	wpa_printf(MSG_DEBUG, "Scan for neighboring BSSes prior to enabling "
@@ -916,7 +954,7 @@
 	if (!hostapd_is_usable_edmg(iface))
 		return 0;
 
-	if (!iface->conf->secondary_channel)
+	if (!iface->conf->secondary_channel || iface->conf->noscan)
 		return 1;
 
 	if (hostapd_is_usable_chan(iface, iface->freq +

--- hostapd.sh.orig	2022-09-10 01:55:41.409228000 +0800
+++ hostapd.sh	2022-09-10 16:32:39.349899173 +0800
@@ -117,6 +117,7 @@
 	config_add_int rssi_ignore_probe_request
 	config_add_int maxassoc
 	config_add_boolean vendor_vht
+	config_add_boolean intel_lar
 
 	config_add_string acs_chan_bias
 	config_add_array hostapd_options
@@ -134,7 +135,7 @@
 
 	json_get_vars country country3 country_ie beacon_int:100 dtim_period:2 doth require_mode legacy_rates \
 		acs_chan_bias local_pwr_constraint spectrum_mgmt_required airtime_mode cell_density \
-		rts_threshold beacon_rate rssi_reject_assoc_rssi rssi_ignore_probe_request maxassoc vendor_vht
+		rts_threshold beacon_rate rssi_reject_assoc_rssi rssi_ignore_probe_request maxassoc vendor_vht intel_lar
 
 	hostapd_set_log_options base_cfg
 
@@ -216,6 +217,7 @@
 				set_default rate_list "24000 36000 48000 54000"
 				set_default basic_rate_list "24000"
 			fi
+			[ -n "$intel_lar" ] && append base_cfg "intel_lar=$intel_lar" "$N"
 		;;
 	esac
 
